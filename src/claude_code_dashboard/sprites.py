"""像素精靈渲染模組 — 使用 Unicode 盲文字元（Braille）繪製 Agent 角色。

每個精靈定義為 14×12 的像素網格，透過 Unicode Braille 字元
（U+2800..U+28FF）渲染為 7 字元寬 × 3 行高的彩色圖像。

.. note::
    每個 Braille 字元編碼一個 2 寬 × 4 高的點陣矩陣，
    因此解析度比一般方塊字元（Block Character）精細 8 倍。
    這是 VS Code 終端機唯一可用的「像素級」繪圖方案，
    因為 VS Code 終端不支援 Sixel、Kitty 或 iTerm2 圖片協議。

像素網格中的色彩代碼::

    0 = 透明（不繪製）
    1 = 膚色
    2 = 頭髮
    3 = 上衣
    4 = 褲子
    5 = 強調色（手部/物品）
    6 = 家具（桌子/鍵盤）
    7 = 特效（思考泡泡、ZZZ 睡眠符號）
"""

from __future__ import annotations

from rich.text import Text

# ── 色彩對應表：像素值 → Rich 樣式名稱 ────────────────────────

COLOR_MAP: dict[int, str] = {
    1: "bright_white",    # 膚色
    2: "#4a9eff",         # 頭髮（藍色）
    3: "#22c55e",         # 上衣（綠色）
    4: "#3b82f6",         # 褲子（藍色）
    5: "#fbbf24",         # 強調色（黃色，代表手部或物品）
    6: "#a78bfa",         # 家具（紫色，代表桌子/鍵盤）
    7: "#94a3b8",         # 特效（灰色，代表思考泡泡或 ZZZ）
}

# ── 精靈像素定義 ───────────────────────────────────────────────
# 每個狀態有兩個畫格（frame），交替顯示以產生動畫效果。
# 矩陣大小：12 行 × 14 欄 = 14×12 像素

# -- 工作中（打字）：手部位置在畫格間左右交替 --

_TYPING_0: list[list[int]] = [
    [0,0,0,2,2,2,2,2,2,0,0,0,0,0],
    [0,0,0,2,2,2,2,2,2,0,0,0,0,0],
    [0,0,0,1,0,1,1,0,1,0,0,0,0,0],  # 眼睛（張開，6px 對稱）
    [0,0,0,1,1,1,1,1,1,0,0,0,0,0],  # 臉下半（6px）
    [0,0,0,0,1,1,1,1,0,0,0,0,0,0],  # 下巴（4px 置中）
    [0,0,0,3,3,3,3,3,3,0,0,0,0,0],  # 衣領（6px）
    [0,0,3,3,3,3,3,3,3,3,0,0,0,0],  # 身體（8px）
    [0,5,0,0,3,3,3,3,0,0,5,0,0,0],  # 左手伸出
    [0,0,0,0,4,4,4,4,0,0,0,0,0,0],  # 褲子（4px 置中）
    [0,0,0,0,4,0,0,4,0,0,0,0,0,0],  # 雙腿
    [6,6,6,6,6,6,6,6,6,6,6,6,0,0],  # 桌子
    [0,0,0,0,0,0,0,0,0,0,0,0,0,0],
]

_TYPING_1: list[list[int]] = [
    [0,0,0,2,2,2,2,2,2,0,0,0,0,0],
    [0,0,0,2,2,2,2,2,2,0,0,0,0,0],
    [0,0,0,1,0,1,1,0,1,0,0,0,0,0],  # 眼睛（張開，6px 對稱）
    [0,0,0,1,1,1,1,1,1,0,0,0,0,0],
    [0,0,0,0,1,1,1,1,0,0,0,0,0,0],
    [0,0,0,3,3,3,3,3,3,0,0,0,0,0],
    [0,0,3,3,3,3,3,3,3,3,0,0,0,0],
    [0,0,5,0,3,3,3,3,0,5,0,0,0,0],  # 右手伸出（手部位置交替）
    [0,0,0,0,4,4,4,4,0,0,0,0,0,0],
    [0,0,0,0,4,0,0,4,0,0,0,0,0,0],
    [6,6,6,6,6,6,6,6,6,6,6,6,0,0],
    [0,0,0,0,0,0,0,0,0,0,0,0,0,0],
]

# -- 思考中：思考泡泡在畫格間變化 --

_THINKING_0: list[list[int]] = [
    [0,0,0,2,2,2,2,2,2,0,0,0,0,0],
    [0,0,0,2,2,2,2,2,2,0,0,0,0,0],
    [0,0,0,1,0,1,1,0,1,0,0,0,0,0],  # 眼睛（往上看，6px 對稱）
    [0,0,0,1,1,1,1,1,1,0,0,0,0,0],
    [0,0,0,0,1,1,1,1,0,0,0,7,0,0],  # 下巴 + 小泡泡
    [0,0,0,3,3,3,3,3,3,0,0,0,0,0],
    [0,0,3,3,3,3,3,3,3,0,7,7,7,0],  # 思考泡泡框
    [0,0,0,0,3,3,3,3,1,0,7,0,7,0],  # 托下巴的手
    [0,0,0,0,3,3,3,3,0,0,7,7,7,0],
    [0,0,0,0,4,0,0,4,0,0,0,0,0,0],
    [0,0,0,0,4,0,0,4,0,0,0,0,0,0],
    [0,0,0,4,4,0,0,4,4,0,0,0,0,0],
]

_THINKING_1: list[list[int]] = [
    [0,0,0,2,2,2,2,2,2,0,0,0,0,0],
    [0,0,0,2,2,2,2,2,2,0,0,0,0,0],
    [0,0,0,1,0,1,1,0,1,0,0,0,0,0],  # 眼睛（6px 對稱）
    [0,0,0,1,1,1,1,1,1,0,0,0,0,0],
    [0,0,0,0,1,1,1,1,0,0,0,0,7,0],  # 泡泡位置偏移
    [0,0,0,3,3,3,3,3,3,0,0,0,0,0],
    [0,0,3,3,3,3,3,3,3,0,0,7,7,0],
    [0,0,0,0,3,3,3,3,1,0,7,0,0,7],
    [0,0,0,0,3,3,3,3,0,0,7,0,0,7],
    [0,0,0,0,4,0,0,4,0,0,0,7,7,0],
    [0,0,0,0,4,0,0,4,0,0,0,0,0,0],
    [0,0,0,4,4,0,0,4,4,0,0,0,0,0],
]

# -- 等待中（等待權限/輸入）：舉手示意 --

_WAITING_0: list[list[int]] = [
    [0,0,0,2,2,2,2,2,2,0,0,0,0,0],
    [0,0,0,2,2,2,2,2,2,0,0,0,0,0],
    [0,0,0,1,0,1,1,0,1,0,0,0,0,0],  # 眼睛（6px 對稱）
    [0,0,0,1,1,1,1,1,1,0,0,0,0,0],
    [0,0,0,0,1,1,1,1,0,0,0,0,0,0],
    [0,5,0,3,3,3,3,3,3,0,0,0,0,0],  # 左手舉起
    [0,5,3,3,3,3,3,3,3,3,0,0,0,0],
    [0,5,0,0,3,3,3,3,0,0,0,0,0,0],
    [0,0,0,0,4,4,4,4,0,0,0,0,0,0],
    [0,0,0,0,4,0,0,4,0,0,0,0,0,0],
    [0,0,0,0,4,0,0,4,0,0,0,0,0,0],
    [0,0,0,4,4,0,0,4,4,0,0,0,0,0],
]

_WAITING_1: list[list[int]] = [
    [0,0,0,2,2,2,2,2,2,0,0,0,0,0],
    [0,0,0,2,2,2,2,2,2,0,0,0,0,0],
    [0,0,0,1,0,1,1,0,1,0,0,0,0,0],  # 眼睛（6px 對稱）
    [0,0,0,1,1,1,1,1,1,0,0,0,0,0],
    [0,0,0,0,1,1,1,1,0,0,0,0,0,0],
    [0,0,0,3,3,3,3,3,3,5,0,0,0,0],  # 右手舉起（交替）
    [0,0,3,3,3,3,3,3,3,5,0,0,0,0],
    [0,0,0,0,3,3,3,3,0,5,0,0,0,0],
    [0,0,0,0,4,4,4,4,0,0,0,0,0,0],
    [0,0,0,0,4,0,0,4,0,0,0,0,0,0],
    [0,0,0,0,4,0,0,4,0,0,0,0,0,0],
    [0,0,0,4,4,0,0,4,4,0,0,0,0,0],
]

# -- 閒置中（睡覺）：ZZZ 符號飄動 --

_SLEEPING_0: list[list[int]] = [
    [0,0,0,2,2,2,2,2,2,0,0,0,0,0],
    [0,0,0,2,2,2,2,2,2,0,0,0,0,0],
    [0,0,0,1,1,0,0,1,1,0,0,0,0,0],  # 眼睛（閉合，6px 對稱）
    [0,0,0,1,1,1,1,1,1,0,0,0,0,0],
    [0,0,0,0,1,1,1,1,0,0,0,0,0,0],
    [0,0,0,3,3,3,3,3,3,0,0,0,0,0],
    [0,0,3,3,3,3,3,3,3,3,0,0,0,0],
    [0,0,0,0,3,3,3,3,0,0,0,0,0,0],
    [0,0,0,0,4,4,4,4,0,0,0,0,0,0],
    [0,0,0,0,4,0,0,4,0,7,7,0,0,0],  # 小 Z
    [0,0,0,0,4,0,0,4,0,0,7,0,0,0],
    [0,0,0,4,4,0,0,4,4,7,7,0,0,0],
]

_SLEEPING_1: list[list[int]] = [
    [0,0,0,2,2,2,2,2,2,0,0,0,0,0],
    [0,0,0,2,2,2,2,2,2,0,0,0,0,0],
    [0,0,0,1,1,0,0,1,1,0,0,0,0,0],  # 眼睛（閉合，6px 對稱）
    [0,0,0,1,1,1,1,1,1,0,0,0,0,0],
    [0,0,0,0,1,1,1,1,0,0,0,0,0,0],
    [0,0,0,3,3,3,3,3,3,0,0,0,0,0],
    [0,0,3,3,3,3,3,3,3,3,0,0,0,0],
    [0,0,0,0,3,3,3,3,0,0,0,0,0,0],
    [0,0,0,0,4,4,4,4,0,0,0,0,0,0],
    [0,0,0,0,4,0,0,4,0,0,0,0,0,0],
    [0,0,0,0,4,0,0,4,0,0,7,7,7,0],  # 大 ZZZ（位置交替）
    [0,0,0,4,4,0,0,4,4,0,0,7,0,0],
]

# ── 狀態 → 動畫畫格對應表 ─────────────────────────────────────
# 每個狀態對應一組畫格清單，透過 frame % len(frames) 實現循環動畫

SPRITE_FRAMES: dict[str, list[list[list[int]]]] = {
    "working":            [_TYPING_0, _TYPING_1],
    "thinking":           [_THINKING_0, _THINKING_1],
    "waiting_permission": [_WAITING_0, _WAITING_1],
    "waiting_input":      [_WAITING_0, _WAITING_1],
    "idle":               [_SLEEPING_0, _SLEEPING_1],
}


def render_sprite(state: str, frame: int) -> Text:
    """將指定狀態的精靈渲染為彩色 Braille 文字。

    根據 ``state`` 選取對應的像素網格，再依 ``frame`` 決定動畫畫格，
    最後透過 :func:`_pixels_to_braille` 轉換為 Rich Text 物件。

    Args:
        state: Agent 狀態字串（例如 ``"working"``、``"idle"``）。
        frame: 動畫畫格計數器。會對畫格總數取餘數以實現循環。

    Returns:
        Rich Text 物件，通常為 7 字元寬 × 3 行高的彩色 Braille 文字。
    """
    frames = SPRITE_FRAMES.get(state, SPRITE_FRAMES["idle"])
    pixels = frames[frame % len(frames)]
    return _pixels_to_braille(pixels)


def _pixels_to_braille(pixels: list[list[int]]) -> Text:
    """將二維像素網格轉換為彩色 Braille Rich Text。

    演算法步驟：

    1. 將像素網格的高度補齊為 4 的倍數、寬度補齊為 2 的倍數
    2. 每 2×4 的像素區塊對應一個 Braille 字元（U+2800 基底）
    3. 區塊內每個非零像素點對應一個 Braille 點位元
    4. 透過「多數決」選出區塊的主要顏色

    Braille 字元的點位對應（col=0 左列, col=1 右列）::

        row 0: bit 0x01  |  bit 0x08
        row 1: bit 0x02  |  bit 0x10
        row 2: bit 0x04  |  bit 0x20
        row 3: bit 0x40  |  bit 0x80

    Args:
        pixels: 二維整數陣列，每個值代表一個顏色代碼（0=透明）。

    Returns:
        Rich Text 物件，包含每個 Braille 字元及其對應的顏色樣式。
    """
    # 複製像素資料，避免修改原始陣列
    px: list[list[int]] = [row[:] for row in pixels]

    # 補齊高度為 4 的倍數
    while len(px) % 4 != 0:
        px.append([0] * (len(px[0]) if px else 0))

    # 補齊寬度為 2 的倍數
    width: int = max(len(r) for r in px) if px else 0
    for r in px:
        while len(r) < width:
            r.append(0)
        if len(r) % 2 != 0:
            r.append(0)

    width = len(px[0]) if px else 0
    height: int = len(px)

    # Braille 點位對應表：(列偏移, 行偏移, 位元值)
    dot_bits: list[tuple[int, int, int]] = [
        (0, 0, 0x01), (0, 1, 0x08),  # 第 0 列
        (1, 0, 0x02), (1, 1, 0x10),  # 第 1 列
        (2, 0, 0x04), (2, 1, 0x20),  # 第 2 列
        (3, 0, 0x40), (3, 1, 0x80),  # 第 3 列
    ]

    text = Text()

    # 每 4 行為一個區塊列、每 2 欄為一個區塊行
    for row_block in range(0, height, 4):
        if row_block > 0:
            text.append("\n")
        for col_block in range(0, width, 2):
            code: int = 0x2800  # Braille 空白字元基底
            color_votes: dict[int, int] = {}  # 顏色投票計數

            for dr, dc, bit in dot_bits:
                r: int = row_block + dr
                c: int = col_block + dc
                if r < height and c < width and px[r][c]:
                    code |= bit  # 設定對應的 Braille 點
                    v: int = px[r][c]
                    color_votes[v] = color_votes.get(v, 0) + 1

            # 以多數決選出此區塊的代表顏色
            if color_votes:
                dominant: int = max(color_votes, key=color_votes.get)  # type: ignore[arg-type]
                style: str = COLOR_MAP.get(dominant, "white")
            else:
                style = ""

            text.append(chr(code), style=style)

    return text
